## Построение солдат

### Условие

В армии некоторого государства построение солдат по росту производится следующим образом: сначала выбирается самый высокий солдат, после чего он несколькими последовательными переменами местами с непосредственными соседями передвигается в начало строя. Далее выбирается самый высокий из оставшихся и ставится на второе место и т. д. Если в строю несколько солдат имеют наибольший рост, то из них выбирается тот, который стоит ближе к началу строя.

Один талантливый полководец заметил, что построение таким образом занимает слишком много времени и придумал свой способ. Для того, чтобы убедить свое консервативное начальство в необходимости применения его метода, полководец решил подсчитать, сколько перемен местами соседних солдат требовалось при использовании старого способа. Таким образом он хотел доказать, что подобная процедура слишком утомительна для солдат. Помогите ему решить эту задачу.

### Решение

Имена тут вообще не нужны, просто усложняют считывание.

Самая очевидная идея:
- завести счетчик
- искать индекс максимального элемента в массиве
- прибавлять к счетчику этот индекс. Это так работает, т.к. нам нужно элемент поставить на 1ое место(сделать его с индексом 0)
- удалять из исходного массива элемент

Данная идея верна, но работает за $O(n^2)$, т.к. мы находим максимальный элемент за $O(n)$ и еще удаляем элемент тоже за $O(n)$ и вылетает TL(Time Limit) на тесте №13 на С.

Менее очевидная идея это заметить, что по сути нам надо **отсортировать** солдат по высоте в обратном порядке.

Но какая сортировка верно посчитает кол-во сдвигов?

Я попросил GPT сгенерировать 10 сортировок:
- Bubble
- Insertion
- Shaker
- Shell
- Merge
- Selection
- Quick
- Heapify
- Cocktail
- Pancake

Потыкав тест с разными вариациями я пришел к выводу, что (Merge Sort)[lessons/11_03/merge_sort.md] выдает верный ответ.