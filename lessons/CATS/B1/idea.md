## План эвакуации

### Условие
В городе, где живет юный программист Вася, построили школу. Когда в школу пошли первые ученики, выяснилось, что план эвакуации в основном коридоре составлен неправильно.

Коридор является одномерным и состоит из 
N клеток, в каждой клетке может находиться только один человек

План эвакуации представляет из себя строку из 
N символов 'L', 'R', 'X'. Символ 'L' означает, что человек, находящийся в данной клетке, в случае эвакуации должен пойти в соседнюю клетку слева. Аналогично, символ 'R' означает, что следует пойти вправо. Символ 'X' означает, что в этой клетке расположен выход.

Предполагается, что при эвакуации в каждой клетке, кроме выходов, будет располагаться один человек и все они начнут двигаться согласно плану эвакуации. Каждый будет выходить в первый выход, который встретится у него на пути.

Чтобы план эвакуации был безопасным, в каждый выход не должно попасть более, чем 
K человек. Также, при эвакуации люди не должны столкнуться друг с другом.

Вам требуется написать программу, которая предложит безопасный план эвакуации.

### Решение

Сначала нужно расставить выходы, поставить 'X' в нужную позицию массива.

*Самая базовая идея* - идти по массиву и, если не дошли до выхода ставить 'R', если прошли выход ставить 'L'. Но данная идея не учитывает заполнение выхода, так что не решает задачу.

*Следующая идея* - идти по массиву и для каждой позиции искать выходы с двух сторон и считать, какой ближе и возвращать его номер(позицю на плане). Если ближайшего выхода нет(-1) возвращается, то план построить невозможно. 

Такая идея пройдет дальше первой(вроде), но она опять не учитывает возможность переполнения выходов.

*Идея №3* - искать ближайшего соседа с двух сторон **с учетом** заполнения выходов. Мы не просто ищем ближайшего соседа, но и смотрим заполнен он или нет(для этого ведем подсчет заполненности каждого выхода). Если нет, то возвращаем его. Если заполнен первый найденный выход, то смотрим на второй, заполнени или нет, если нет, то возвращаем его. Если оба заполнены, то выхода нет и плана нет такого.

В этих идеях есть возможность получить переполненные выходы, в идеи №3 точно. Логично, что такого плана нет и мы выводим 'NO' и все, ответ готов.

#### Решение верное

Проблема предыдущих идей - получение переполненных выходов и их неверная обработка.

Да, выход могут получиться переполненными, **НО** почему плана нет? Просто потому что он переполнен?

Если действовать такой логике, то тест №37 не будет пройден.

Одна из найденный мною вариаций данного теста:
$$
\begin{align}
	\begin{aligned}
		\text{27 9 3}\\
		\text{2 3 4 9 13 19 20 22 25}
	\end{aligned}
	& \quad \to \quad
	\begin{align}
    \text{RXXXLLLRXLLRXLLRRRXXLXLLXLL}
	\end{align}
\end{align}
$$

Рассмотрим вывод ответа на основе идеи №3:
- для каждой позиции ищем ближайшего соседа;
- проверяем заполнен он или нет;
- пишем 'L' или 'R' в зависимости от выхода.

В итоге получем такой массив:
```python
['R', 'X', 'X', 'X**', 'L', 'L', 'R', 'R', 'X', 'L', 'R', 'R', 'X', 'L', 'R', 'R', 'R', 'R', 'X*', 'X', 'L', 'X', 'L', 'R', 'X', 'L', 'L']
```

Видно, что выход на позиции 19('X*'), по исходным данным, переполнен и в нем 4 человека. Людей 4, $4 > 3(k) \to$ ответ 'NO'.

Но можно заметить, что выход на позиции 4('X**') не заполнен до конца, в нем 2 человека. Если он не заполнен, можем ли мы добавить туда человека?

Да. Поменяется план после этого? Конечно. Так перестроим план так, чтобы каждый выход был забит по максимуму.

Возьмем полученный план и пройдемся по нему еще раз, но только будем его переделывать, заполняя **не** заполненные выходы до k.

Таким образом и получается верный ответ - нужно полностью забивать каждый выход до k.