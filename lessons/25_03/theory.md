## Lambda в C++

Лямбда в С++ позволяют инициализировать **анонимную** функцию, которая может быть использована как обычная функция или передана как аргумент. Часто используется при сортировке, фильтрации.

Базовый синтаксис ламбда функции выглядит так:
```c++
auto greet = []() {
  cout << "Hello!" << endl;
};
```

В данной записи:
- **[]** - ламбда-введение(lambda introducer), который обозначет начало лямбда-выражения;
- **()** - список параметров как и обычной функции.

Код выше эквивалентен обычному определнию функции:
```c++
void greet() {
  cout << "Hello!" << endl;
}
```

Если не передавать ламбду как аргумент, то она вызывается как обычная функция:
```c++
int main() {
  auto greet = []() {
    cout << "Hello!" << endl;
  };

  greet();
}
```

### Лямбда-функции с параметрами
Так же, реализуем пример лямбда-функции с параметрами:
```c++
int main() {
  auto add = [] (int a, int b) {
    cout << "Sum = " << a + b;
  };

  /* 
    Эквивалентно:
    void add(int a, int b) {
      cout << "Sum = " << a + b; 
    }
  */

  add(1, 68);
}
```

Лямбда-функции могут возвращать значения. Если оператор **return** один и не надо как-то преобразовывать данные, то можно не указывать тип:
```c++
auto add = [] (int a, int b) {
  // Всегда возвращает 'int'
  return a + b;
};
```

Но если операторов несколько и они возвращают разные типы(int или double), то нужно явно указать тип(double, например):
```c++
auto operation = []  (int a, int b,  string op) -> double {
  if (op == "sum") {
    // Bозвращает int
    return a + b;
  } 
  else {
    // Возвращает double
    return (a + b) / 2.0;
  }
};
```

Если явно не указать тип, то будет ошибка. Код сработает так:
- тип явно не передан, значит присваиваем тип первого *retrun*;
- аргументы имеют тип *int*, их сумма тоже является *int* $\rightarrow$ лямбда-функиця тоже *int*;
- в блоке *else* возвращают *double*, но уже присвоен тип функции *int* $\rightarrow$ ошибка ```error: inconsistent types 'int' and 'double' deduced for lambda return type```

### Ламбда-функции с захватом переменных

Изначально ламбда-функция не имеет возможности обращаться к переменным **вне** своего блока функции.

Это можно исправить, передав перменную в *[]* у лямбды:
```c++
int num_temp = 100;

auto lambda = [num_temp]() {
  cout << num_temp;
};
```
Можно передавать переменную и по ссылке:
```c++
int num_temp = 100;

auto lambda = [&num_temp]() {
  num_temp = 69;
};
```
Можно передавать несколько переменных через запятую:
```c++
auto my_lambda = [a, b, c, d, e] (){
  // lambda body
};
```
Но, если мы хотим передать **все** внешние переменные в лямбду, то можно сделать так:
```c++
auto my_lambda = [=] (){
  // lambda body
};
```
Если пойти еще дальше и захотеть разрешать лямбде менять **все** внешние переменные, то можно сделать так:
```c++
auto my_lambda = [&] (){
  // lambda body
};
```

### Лямбда-функция как аргумент

В некоторые функции можно передавать лямбда-функции как аргумент для условий.

##### Пример 1
Нужно посчитать в массиве кол-во **четных** чисел. Есть функция **count_if** в *\<algorithm>*, которая принимает начало и конец массива, в котором нужно чт-то посчитать и условие:
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
  vector<int> nums = {1, 2, 3, 4, 5, 8, 10, 12};

  int even_count = count_if(nums.begin(), nums.end(), [](int num) {
    return num % 2 == 0;
  });

  cout << "There are " << even_count << " even numbers.";

  return 0;
}
```
В данном примере мы в **count_if** передаем лямбду, которая определяет условие подсчета. По факту, **count_if** будет проходится по каждому элементу массива, проверять его по условию и увеличивать счетчик. Поскольку при прохождении по массиву **каждый элемент** это *int*, то и в лямбду мы передаем *int* аргумент, **который представляет собой элемент массива**.

##### Пример 2
Нужно отсортировать массив в обратном порядке, в порядке убывания.

Для этого нужно реализовать лямбду у функции ``sort``:
```c++
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {5, 1, 4, 2, 3};
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) { 
      return a > b; 
    });

    for (int n : numbers) {
        std::cout << n << " ";
    }
    return 0;
}
```

В данном случае, **a > b** указывает порядок сортировки, от большего у меньшему.