# АВЛ-деревья

**АВЛ-дерево** - сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

Каждый узел хранит не только ключ, но и высоту поддерева, и при каждой вставке/удалении дерево следит, чтобы не "перекоситься".

АВЛ — аббревиатура, образованная первыми буквами создателей (советских учёных) Адельсона-Вельского Георгия Максимовича и Ландиса Евгения Михайловича.

Максимальная высота - $h <= \lfloor \frac{log_2(n + a)}{b} - c \rfloor <= \lfloor 1.45log_2(n+2) \rfloor$, где:

- $a = \frac{1 + \frac{3}{\sqrt5}}{2} \approx 1.17082$, округлить вверх;

- $b = log_2(\frac{1 + \sqrt 5}{2}) \approx 0.69424$, округлить вниз;

- $c = 2- \frac{log_2 5}{2b} \approx 0.322724$, округлить вниз.

По сути, вот пример узла дерева:
```c++
struct Node {
    int key;  // Значение
    Node* left;  // Левый потомок
    Node* right;  // Правый потомок
    int height;  // Высота узла
};
```

При вставке или удалении элемента может произойти *расбалансировка* дерева. Вычисляется некий balance:

- balance = height(left) - height(right);

- Если $balance \in \{-1, 0, 1\}$, то дерево сбалансировано;

- В других случаях нужна балансировка.

Выделяют следующие балансировки:
- левый поворот;
- правый поворот.

![Визуализация](https://habrastorage.org/r/w780/storage2/08e/55b/834/08e55b834b268b34eea7cb787094bd57.png)

### Правый поворот

1. Текущий корень поддерева (D) заменяется на левый дочерний узел (B)

2. Предыдущий корень (D) становится правым дочерним узлом для (B)

3. Предыдущее правое поддерево узла (B) становится левым поддеревом для (D)
![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImJhZjZiYjFmMDhkZGQ2NjlkYjk2NjRmMzk3NDIzNTUzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ea8a77847af78339ded932fe9cc2822285de8347b4ef98bd43642143056d5f0b)

### Левый поворот

1. Текущий корень поддерева (D) заменяется на правый дочерний узел (С)

2. Предыдущий корень (D) становится левым дочерним узлом для (С)

3. Предыдущее левое поддерево узла (С) становится правым поддеревом для (D)
![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjExNDkzNTNkMjY3MzYwMDVhZDM0OTJkMWU2ZmY4ZmE1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=78860db9d95739545c17c974509cfdd301173517f23d32d44b367e178b25fd3b)

### Добавление вершин

В зависимости от того, куда добавили новую вершину, возможны различные комбинации выполнения вращений. Они помогут вернуть дерево в сбалансированное состояние.

Всего выделяется четыре варианта развития событий:

- Левое поддерево левой дочерней вершины

- Левое поддерево правой дочерней вершины

- Правое поддерево левой дочерней вершины

- Правое поддерево правой дочерней вершины

Рассмотрим пример, который описывает первый случай — вставку в левое поддерево левой дочерней вершины. Изображенные треугольники представляют собой сбалансированные АВЛ-поддеревья. Они могут содержать большое количество вершин. У вершины В дерево не сбалансировано, поскольку поддерево А1 в вершине А на два уровня выше, чем поддерево В2:
![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA0OWRhMWI1MjFiYWE2YmQ1ZWU3NmU5ZjFkNzdiMjA2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1a1f9f9a41978e1e4f274bb5086b341eb58797fdb47759386cabd390f9ab22ff)

Чтобы сбалансировать дерево, необходимо совершить правое вращение — заменить вершину В вершиной А и сделать поддерево А2 левым поддеревом вершины В. После такого преобразования наше поддерево примет следующий вид:
![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQyYTY5Y2NmZDIwODBlN2NkY2QzZjA5YTE0YmY3ZmM4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=0d3e47a950fefde6e07601898f2999052cb2619c159e9bff502a98540998d7c9)
Четвертый сценарий будет выглядеть аналогично кроме замены способа вращения на левое.

Для второго и третьего сценариев необходимо выполнить вращение дважды:
![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE5NjI2ZjVjZDM1OWQwNjI5MDgyZmZjZjdiZmFhZjEzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c8fc756bb4543a50c56bfc9572cba96ca88eb3ce3445a1aafe2420c470dcc40e)

### Удаление

Удаление узлов также осуществляется при помощи механизмов вращения. При возврате во время рекурсивного спуска осуществляется вычисление balanceFactor. Если он отклоняется от допустимых значений, то выполняется ребалансировка аналогично добавлению узла.

![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImM0NjRmNzkyMjdkMDk4MDU2MmU2OTdlNzlkOTRjZDA4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=131dc43ac638fb4d07ef598161014bb45ac668c67156fccd9d5cedf8d73ec150)